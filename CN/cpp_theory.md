### C++内存布局各个区的功能 Memory Layout 

https://www.geeksforgeeks.org/memory-layout-of-c-program/

环境变量：程序的命令行参数和环境变量

栈：由系统自动分配释放。栈指针指向当前的栈顶位置；一个栈帧中包含函数的返回地址、局部变量、函数参数

堆：内存动态分配区段，通过malloc, realloc, and free, new, delete对这个区段的内存进行管理。如果分配的内存没有被释放，程序结束时由操作系统进行回收。

未初始化的数据区：未初始化的全局变量和静态变量，这个区域的数据在程序执行前会被内核自动初始化

已初始化的数据区：分为只读区域和可读写区域，只读区域为常量区，例如字符串常量。可读写区为已初始化的全局变量和静态变量

程序代码区：包含可执行指令，通常在内存空间的最低址，以防止堆或栈溢出，通常这一个区间的数据是不允许修改只能执行的。



### 堆和栈的区别？（**从调用和内存分布两方面**） 

1. 管理方式不同。栈由操作系统自动分配释放，无需我们手动控制；堆的申请和释放工作由程序员控制，容易产生内存泄漏；

2. 空间大小不同。每个进程拥有的栈的大小要远远小于堆的大小。理论上，程序员可申请的堆大小为虚拟内存的大小，进程栈的大小 64bits 的 Windows 默认 1MB，64bits 的 Linux 默认 10MB；

3. 生长方向不同。堆的生长方向向上，内存地址由低到高；栈的生长方向向下，内存地址由高到低。

4. 分配方式不同。堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是由操作系统完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由操作系统进行释放，无需我们手工实现。

5. 分配效率不同。栈由操作系统自动分配，会在硬件层级对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是由C/C++提供的库函数或运算符来完成申请与管理，实现机制较为复杂，频繁的内存申请容易产生内存碎片。显然，堆的效率比栈要低得多。

6. 存放内容不同。

   https://blog.csdn.net/K346K346/article/details/80849966

   

### 栈里除了局部变量还会存什么

Input Parameters, Return address, frame pointer, local variables, saved register



### 字节对齐

字节对齐主要是为了提高内存的访问效率，比如intel 32位cpu，每个总线周期都是从偶地址开始读取32位的内存数据，如果数据存放地址不是从偶数开始，则可能出现需要两个总线周期才能读取到想要的数据，因此需要在内存中存放数据时进行对齐。



### 函数调用的过程

https://www.cnblogs.com/sddai/p/9762968.html

1. 输入参数入栈
2. 返回地址入栈，返回地址为调用者下一条可执行指令的地址
3. 基指针base pointer入栈，ebp
4. 将ebp设置为esp的值
5. 分配空间给局部变量



### 源码到可执行文件的过程

1. 预编译(Preprocessing)：处理源代码文件中的以“#”开头的预编译指令。展开所有的宏定义；处理所有的条件预编译指令；处理“#include”预编译指令；删除所有的注释；添加行号和文件标识
2. 编译(Compilation)：词法分析，语法分析，语义分析，中间代码生成，中间代码优化，生成目标代码
3. 汇编(Assembly)：将汇编代码翻译成机器可以执行的机器指令。
4. 链接(Linking)：链接器（ld）将多个目标文件（.o文件）合并为一个可执行文件。合并段，合并符号表，分配内存地址



### 编译过程

词法分析，语法分析，语义分析，中间代码生成，中间代码优化，生成目标代码



### 静态编译和动态编译的区别

静态编译在编译可执行文件的时，将可执行文件需要调用的动态链接库中的部分提取出来，链接到可执行文件中去，使可执行文件在运行时不依赖于动态链接库。

动态编译的可执行文件需要附带一个动态链接库，在执行时，需要调用其对应动态链接库中的命令。其优点是缩小了执行文件本身的体积，加快了编译速度，节省系统资源。缺点一是哪怕是很简单的程序，只用到了链接库中的一两条命令，也需要附带一个相对庞大的链接库；二是如果其他计算机上没有安装对应的 运行库，则用动态编译的可执行文件就不能运行。



### lib文件与ddl文件

1. lib是编译时需要的（相当于头文件声明），dll是运行时需要的（相当于函数的实现）。
2. 一般的动态链接库程序有lib文件和dll文件。lib文件在编译期链接到程序中的，dll文件是运行期被调用。如果动态链接库中同时有lib和dll文件，那么lib文件中一般是一些索引信息，具体的实现在dll文件中。如果只有lib文件，那么这个lib文件是静态编译出来的，索引和实现都在其中。静态编译的lib文件有好处：给用户安装时就不需要再挂动态库了。但缺点是程序比较大，而且失去了动态库的灵活性，在版本升级时，同时要发布新的应用程序才行。
3. 在动态库的情况下，有两个文件，一个是引入库（.LIB）文件，一个是DLL文件，引入库文件包含被DLL导出的函数的名称和位置，DLL包含实际的函数和数据，应用程序使用LIB文件链接到所需要使用的DLL文件，库中的函数和数据并不复制到可执行文件中，因此在应用程序的可执行文件中，存放的不是被调用的函数代码，而是DLL中所要调用的函数的内存地址，这样当一个或多个应用程序运行是再把程序代码和被调用的函数代码链接起来，从而节省了内存资源。从上面的说明可以看出，DLL文件必须随应用程序一起发行，否则应用程序将会产生错误。



### 动态链接和静态链接

静态链接：在编译阶段将源文件需要的目标文件进行链接，从而形成一个可以执行的程序。

缺点1浪费空间，因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o；另一方面就是更新比较困难，因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快。

动态链接：把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

动态链接的优点是即使需要每个程序都依赖同一个库，但是该库不会像静态链接那样在内存中存在多分副本，而是这多个程序在执行时共享同一份副本；另一个优点是，更新也比较方便，更新时只需要替换原来的目标文件，而无需将所有的程序再重新链接一遍。当程序下一次运行时，新版本的目标文件会被自动加载到内存并且链接起来，程序就完成了升级的目标。但是动态链接也是有缺点的，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。

https://blog.csdn.net/kang___xi/article/details/80210717



### 程序执行的过程

https://blog.csdn.net/kang___xi/article/details/79571137



### 原码，反码，补码

原码：原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 比如如果是8位二进制: +1 = 0000 0001；-1 = 1000 0001

反码：正数的反码是其本身；负数的反码是在其原码的基础上, 符号位不变，其余各个位取反。

+1 = 0000 0001；-1 =  1111 1110

补码：正数的补码就是其本身，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

+1 = 0000 0001；-1 =  1111 1111

https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html



### 为什么负数要用补码

符号位也能参与运算的方法，正数加负数得到正确的结果

将减法变成加法，无需减法器

解决反码中有+0和-0的问题，满足负数的取值范围



### 小数用二进制如何表示

https://blog.csdn.net/xingtanzjr/article/details/50803832

十进制小数转二进制： 乘二法

二进制小数转十进制：与整数类似



### 浮点数在内存当中如何存储的

https://www.jianshu.com/p/8ee02e9bb57d

+/- fraction * 2^exponent

sign: 符号位，占据最高位(第31位)这一位, 用于表示这个浮点数是正数还是负数, 为0表示正数, 为1表示负数.

biased exponent: 偏移后的指数位。指数位占据第30位到第23位这8位. 用于表示以2位底的指数。8位二进制可以表示256种状态, IEEE754规定, 指数位用于表示[-127, 128]范围内的指数. 不过为了表示起来更方便, 浮点型的指数位都有一个固定的偏移量(bias), 用于使 指数 + 这个偏移量 = 一个非负整数. 这样指数位部分就不用为如何表示负数而担心了. 规定: 在32位单精度类型中, 这个偏移量是127. 即, 如果你运算后得到的指数是 -127, 那么偏移后, 在指数位中需要表示为: -127 + 127(偏移量) = 0

fraction: 尾数位，占据剩余的22位到0位这23位. 用于存储尾数. 在以二进制格式存储十进制浮点数时, 首先需要把十进制浮点数表示为二进制格式, 然后需要把这个二进制数转换为以2为底的指数形式, 注意转换时, 对于乘号左边, 加粗的那个二进制数**1.01001**, 需要把小数点放在左起第一位和第二位之间. 且第一位需要是个非0数. 这样表示好之后, 其中的**1.01001**就是**尾数.**

20.5 = 二进制10100.1

二进制10100.1 = **1.01001** * 2^4



### 如何判断两个浮点数相等

由于浮点数的表示是不精确的，所以不能直接比较两个数是否完全相等。一般都是在允许的某个范围内认为某个个浮点数相等，如有两个浮点数a、b，允许的误差范围为 1e-6，则 abs(a-b) <= 1e-6，即可认为 a 和 b 相等。



### malloc与new的区别

1. new/delete是C++操作符，malloc/free是C/C++函数。
2. 分配内存的大小：new由编译器根据类型计算得出；malloc必须显式指定字节数
3. 调用构造函数与析构函数：new调用，malloc不调用
4. 内存分配成功的返回值：new返回完整类型指针；malloc返回void*。
5. 内存分配失败的返回值：new默认抛出异常；malloc返回NULL
6. 分配内存时内存不足：new客户能够指定处理函数或重新制定分配器；malloc无法通过用户代码进行处理
7. 已分配内存的扩充：new无法直观地处理；malloc的指针使用realloc简单完成
8. 函数重载：new可以；malloc不可以

https://www.cnblogs.com/qg-whz/p/5140930.html



### malloc申请内存的注意事项

1. 判断内存是否申请成功，if( NULL !=p )
2. 必须对malloc返回的指针进行强制类型转换
3. 分配的内存空间需要初始化
4. free释放无用内存
5. free后将指针设置为NULL
6. 注意不要double free



### malloc有什么特点

原始，简单



### 写malloc分配数组的代码，然后对其free

```cpp
#include <stdlib.c>

int main()
{
    int *ptr;
    int arrSize = 10;
    arr = (int*) malloc(arrSize * sizeof(int));
    if (arr == NULL) {
        exit(0);
    }
    free(arr);
    arr = NULL;
}
```



### 为什么malloc需要指定size，free不需要指定size

因为内存区域的头部有小段空间用于记录内存块的信息，例如内存大小，在free一段内存空间时可以用过这一段内存信息知道内存空间的大小。



### 手写memcpy

```cpp
#include<stdio.h>
#include<string.h>

void *myMemCpy (void * dst, const void * src, size_t len)
{
	char *d = (char*)dst;
	const char *s = (char*)src;

	for (size_t i = 0; i < len; ++i) {
		d[i] = s[i];
	}
	return dst;
}

int main()
{
    char src[] = "hello world";
    char dst[100];
    myMemCpy(dst, src, strlen(src)+1);
    printf("%s", dst);
    return 0;
}
```



### 手写strcpy

```cpp
#include <stdio.h>

char *strcpy(char *dst, const char *src)
{
    if (dst == NULL)
        return nullptr;

    char *head = dst;
    while (*src != '\0') {
        *dst = *src;
        dst++;
        src++;
    }
    *dst = '\0';
    return head;
}

int main()
{
    char *src = "hello world";
    char dst[100];
    printf("%s", strcpy(dst, src));
    return 0;
}
```



### 手写memset

https://blog.csdn.net/tsh123321/article/details/52263707





### 能否用memcmp比较两个结构体

不能，结构体内存字节对齐会补随机数据



### 栈空间大小及查看

Linux下，默认栈空间大小为8MB，可通过ulimit -s来设置。特点：栈的速度快、空间小，不灵活



### 变量分配内存的方式有哪些

1)从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量。

2)在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。

3)从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。



### C++中的内存泄漏（举例几个内存泄漏的场景）

1. 在类的构造函数和析构函数中没有匹配的调用new和delete函数
2. 没有正确地清除嵌套的对象指针
3. 在释放对象数组时在delete中没有使用方括号
4. 没有将基类的析构函数定义为虚函数

https://blog.csdn.net/lovely20085901/article/details/39050085



### 什么情况下会出现段错误，为什么段错误程序会直接终止

**一个越界的指针，如果不引用它，是不会引起SIGSEGV的。而即使引用了一个越界的指针，也不一定引起SIGSEGV。**

https://blog.csdn.net/u010150046/article/details/77775114



### 函数重载参数列表相同怎么解决同名冲突

https://www.cnblogs.com/skynet/archive/2010/09/05/1818636.html

同名函数会根据参数类型和数量的不同，编译成不同的函数名，这样在链接阶段就可以正确的区分，从而实现重载。



可执行文件的文件格式（ELF文件格式）

new的底层实现，如何分配内存
### 如何理解面向对象

在面向对象的程序中。程序的基本单元是类，程序面对的是一个个类和对象。除了主函数，其他的函数基本都在类中，只有通过类才能调用类中的函数.

封装：可以隐藏实现细节，使得代码模块化；封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面。把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

继承：可以扩展已存在的代码模块（类）；它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。其继承的过程，就是从一般到特殊的过程。

多态：接口重用，允许将父对象设置成为和一个或更多的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。

https://blog.csdn.net/IOT_SHUN/article/details/79674293



### 如何理解面向过程

面向过程，函数是构成程序的基本部分，程序面对的是一个个函数。每一个函数都独立存在于程序中，除了主函数只能被操作系统调用外，其他函数可以相互调用。程序从main函数开始按照编程人员的设计顺序执行。



### 面向对象和面向过程的区别，举例说明

面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；

面向对象是把构成问题事务分解成各个对象，建立对象的目的不是为了完成一个步骤，而是为了描叙某个事物在整个解决问题的步骤中的行为。

面向过程是编年史。
面向对象是纪传史。



### 面向过程和面向对象各自的优缺点

优点：性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素。
缺点：没有面向对象易维护、易复用、易扩展

优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护
缺点：性能比面向过程低



### C与C++区别

c++ = c + oop + template范型编程 + stl



### C实现面向对象

 struct：封装与继承

多态：函数指针



### struct 和 class 在定义或操作特性上有什么不同

1. 默认的继承访问权限。struct 是 public 的，class 是 private 的。
2. struct 默认的数据访问控制是 public 的，而 class 默认的成员变量访问控制是 private 的。

https://blog.csdn.net/alidada_blog/article/details/83419757



### 继承的底层原理

一个派生类对象将包含多个组成部分：一个含有派生类自己定义的成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，那么这样的子对象也有多个。



### 三种继承

1. 单继承
2. 多继承
3. 虚继承



### 如何理解继承

通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类，其他类则直接或间接地从基类继承而来，这些继承得到的类称为派生类。基类负责定义在层次关系中所有类共同拥有的成员，而每个派生类定义各自特有的成员。



### 如何理解多重继承

 多重继承是指从多个直接基类中产生派生类的能力。多重继承的派生类继承了所有父类的属性。



### 如何解决多继承钻石模型（虚继承）

在派生列表中使用关键字virtual继承基类。这样在派生类对象中，虚基类只有一份，即使该虚基类在继承体系中出现了多次也是这样。虚基类将被最底层的派生类初始化。



### 什么是多态，举例

程序通过指针的动态类型获取类型特定行为的能力

当使用基类的引用或指针调用基类中定义的一个函数时，并不知道该函数真正作用的对象是什么类型，因为它可能是一个基类类型，也可能是一个派生类类型。如果这个函数是一个虚函数，那么直到运行时才会决定到底执行哪个版本，判断的依据是引用或指针绑定的对象的真实类型。



### 运行时多态与编译时多态

运行期多态的实现依赖于虚函数机制。当某个类声明了虚函数时，编译器将为该类对象安插一个虚函数表指针，并为该类设置一张唯一的虚函数表，虚函数表中存放的是该类虚函数地址。运行期间通过虚函数表指针与虚函数表去确定该类虚函数的真正实现。



### 多态性、动态绑定的底层原理



### 虚函数表和虚指针存放在哪

虚函数表在类中，vptr在对象中



### 重载overload，覆盖override，隐藏hide的区别

重载是指不同的函数使用相同的函数名，但是函数的参数个数或类型不同。调用的时候根据函数的参数来区别不同的函数。

 覆盖（也叫重写）是指在派生类中重新对基类中的虚函数（注意是虚函数）重新实现。即函数名和参数都一样，只是函数的实现体不一样。

   隐藏是指派生类中的函数把基类中相同名字的函数屏蔽掉了。隐藏与另外两个概念表面上看来很像，**“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下**
（1）如果派生类的函数与基类的函数同名，但是参数不同。此时，不论有无virtual关键字，基类的函数将被隐藏（注意别与重载混淆）。
（2）如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有virtual 关键字。此时，基类的函数被隐藏（注意别与覆盖混淆）

https://www.cnblogs.com/txwsh1/archive/2008/06/28/1231751.html



### 虚函数与纯虚函数的区别

纯虚函数没有函数的定义



### 构造函数中能不能调用虚函数

可以，但不会达到预期的效果

父类先于子类被构造，当父类中的构造函数被调用时，子类还没有形成，此时子类对于编译器来说是不存在的，所以调用的仍是父类本身的虚函数。



### 对象的什么函数不能被声明为虚函数

1. 构造函数
2. 静态函数
3. 内联函数



### 类的构造函数、析构函数可不可以是虚函数

构造函数不能为虚函数，而析构函数可以且常常是虚函数。

如果构造函数是虚函数，那么就需要通过**vtable** 来调用，但此时面对一块 raw memeory，到哪里去找 **vtable** 呢？毕竟，**vtable** 是在构造函数中才初始化的啊，而不是在其之前。因此构造函数不能为虚函数。

况且我们通常通过基类的指针来销毁对象，如果析构函数不为虚的话，就不能正确识别对象类型，从而不能正确销毁对象。



### 怎么用一个指向子类的基类指针调用基类的虚函数

（强制转换或者指明作用域d->Base::fun()）



### 什么时候会调用复制构造函数

1. 新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用。
2. 函数返回值为对象
3. 函数参数为对象



### 构造析构顺序

在类被构造的时候，先执行虚拟继承的父类的构造函数，然后从左到右执行普通继承的父类的构造函数，然后按照定义的顺序执行数据成员的初始化，最后是自身的构造函数的调用。析构函数与之完全相反，互成镜像。

http://gaocegege.com/Blog/cpp/cppclass



### 析构函数的触发机制

1. 使用 **delete** 运算符显式解除分配了使用 **new** 运算符分配的对象。 

2. 具有块范围的本地（自动）对象超出范围。

3. 临时对象的生存期结束。

4. 程序结束，并且存在全局或静态对象。

5. 使用析构函数的完全限定名显式调用了析构函数。

   https://www.cnblogs.com/fnlingnzb-learner/p/9521973.html





默认生成的构造函数

如何统计类的实例化次数 

泛型编程

### 委托构造函数

C++能否在有参构造函数中调用无参构造函数，

无参构造函数中如果有修改类成员会不会对当前正在构造的类产生影响，这种调用方式有什么优势或者缺点。





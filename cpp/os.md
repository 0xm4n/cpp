### 进程和线程的区别

进程是运行中的程序，线程是进程的内部的一个执行序列

进程是资源分配最小单位，线程是程序执行的最小单位；

进程间切换代价大，线程间切换代价小

进程拥有资源多，线程拥有资源少

多个线程共享进程的资源



### 进程间通讯方式及优缺点

pipe

fifo

signal

消息队列

共享内存

信号量 semophore

socket

https://www.cnblogs.com/luo77/p/5816326.html

https://blog.csdn.net/violet_echo_0908/article/details/51201278



### 为什么共享内存是进程高级通信方式最快的方式

采用共享内存进行通信的一个主要好处是效率高，因为进程可以直接读写内存，而不需要任何数据的拷贝，对于像管道和消息队里等通信方式，**则需要再内核和用户空间进行四次的数据拷贝，而共享内存则只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件。**



### 进程切换开销

1. 切换虚拟地址空间(切换页表全局目录, 刷新TLB)
2. 切换CPU上下文( CPU 寄存器和程序计数器, ip, bp, sp)
3. 切换内核态

https://blog.csdn.net/l13763338360/article/details/104961469

https://zhuanlan.zhihu.com/p/79772089



### 线程切换开销

1. 切换CPU上下文
2. 切换内核态

https://www.geeksforgeeks.org/difference-between-thread-context-switch-and-process-context-switch/



### 进程调度算法

1. FCFS 先来先服务
2. SJF 短进程优先
3. RR时间轮片法
4. 多级反馈队列调度算法
5. HPF优先级调度法

https://www.jianshu.com/p/ecfddbc0af2d

https://blog.csdn.net/fuzhongmin05/article/details/55802925



### 孤儿进程

一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。



### 僵尸进程

一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。

https://www.cnblogs.com/anker/p/3271773.html



### 线程间共享的资源

1. 堆
2. 全局变量
3. 静态变量
4. 文件等公共资源



### 每个线程独享的资源

1. 线程ID
2. 栈
3. 寄存器

https://blog.csdn.net/sinat_21026543/article/details/81912378





 ### 线程间同步机制

1. 临界区
2. 互斥量
3. 信号量
4. 时间

https://blog.csdn.net/guoxiang3538/article/details/79376191



### 线程安全



### 哪些类是线程安全的



### 多进程和多线程的区别

数据:多进程数据是分开的，共享复杂，需要用IPC;同步简单;多线程共享进程数据：共享简单；同步复杂

内存、CPU: 多进程占用内存多，切换复杂，CPU利用率低;多线程占用内存少，切换简单，CPU利用率高

创建销毁、切换:多进程创建销毁、切换复杂，速度慢 ;多线程创建销毁、切换简单，速度快 

编程调试:多进程编程简单，调试简单;多线程编程复杂，调试复杂

可靠性:进程间不会相互影响 ;一个线程挂掉将导致整个进程挂掉



https://blog.csdn.net/linraise/article/details/12979473



### C++多线程

thread()

join()

detach()

https://blog.csdn.net/u011808673/article/details/80811998



### 多线程使用时需要注意什么



### 如何实现服务器的多线程

### 线程池实现



### 进程池和线程池

在面向对象程序编程中，对象的创建与析构都是一个较为复杂的过程，较费时间，所以为了提高程序的运行效率尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。
所以我们可以创建一个进程池（线程池）,预先放一些进程（线程）进去,要用的时候就直接调用,用完之后再把进程归还给进程池,省下创建删除进程的时间,不过当然就需要额外的开销了。
利用线程池与进程池可以使管理进程与线程的工作交给系统管理，不需要程序员对里面的线程、进程进行管理。

https://zhuanlan.zhihu.com/p/341855289



### 协程

**协程是一种用户态的轻量级线程，**协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。

https://www.cnblogs.com/lxmhhy/p/6041001.html



### 协程与线程的区别

1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样python中则能使用多核CPU。

2) 线程进程都是同步机制，而协程则是异步

3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态



### 分配给进程的资源有什么

https://blog.csdn.net/lvyibin890/article/details/82193900

内核空间

PCB

用户空间



 ### 虚拟地址空间的作用

https://www.cnblogs.com/wujing-hubei/p/6253380.html

1. 进程地址空间不隔离，内存保护
2. 内存使用效率低，程序需要的内存比实际的物理内存要大
3. 程序运行的地址不确定，简化内存管理



 ### 虚拟内存转换

CPU产生虚拟地址，然后从虚拟地址中得到虚拟页号，接下来通过将虚拟页号作为索引去查找页表，通过得到对应PTE上的有效位来判断当前虚拟页是否在主存中，若命中则将对应PTE上的物理页号和虚拟地址中的虚拟页偏移进行串联从而构造出主存中的物理地址，否则未命中（专业名词称为“缺页”），此时MMU将引发缺页异常，从CPU传递到操作系统内核处理缺页异常处理程序，此时将选择一个牺牲页并将对应所缺虚拟页调入并更新页表上的PTE，缺页处理程序再次返回到原来的进程，再次执行缺页指令，CPU重新将虚拟地址发给MMU，此时虚拟页已存在物理内存中，所以命中，最终将请求的字返回给处理器。

https://www.cnblogs.com/CreateMyself/p/12969171.html



### 物理内存页面置换算法

1. optimal（OPT）：理想情况下的页面置换算法，但实际上是不可能实现的。有些页面在内存中，其中有一页将很快被访问，而其他页面则可能要到10、100或者1000条指令后才会被访问，每个页面都可以用在该页面首次被访问前所要执行的指令数进行标记。最佳页面置换算法只是简单地规定：标记最大的页应该被置换。

2. FIFO：总是选择在主存中停留时间最长（即最老）的一页置换，即先进入内存的页，先退出内存。理由是：最早调入内存的页，其不再被使用的可能性比刚调入内存的可能性大。

3. LRU Least Recently Used：与每个页面最后使用的时间有关的。当必须置换一个页面时，LRU算法选择过去一段时间里最久未被使用的页面。




### LRU实现



### IO多路复用

内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程进行处理。与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。

目前支持I/O多路复用的系统调用有 `select，pselect，poll，epoll`，I/O多路复用就是`通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作`。`但select，pselect，poll，epoll本质上都是同步I/O`，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。



### select，poll，epoll

select: 将fd数组从用户空间传入内核空间，采用轮询的方式进行扫描，当发现某个fd准备就绪时，函数返回。

epoll: 使用“事件”通知就绪，一旦fd就绪，内核就会采用类似callback的回调机制来激活该fd

1. 支持一个进程所能打开的最大连接数

2. FD剧增后带来的IO效率问题

3. 消息传递方式

   https://www.jianshu.com/p/dfd940e7fca2



### epoll为什么用红黑树

https://blog.csdn.net/Mr_H9527/article/details/99745659

https://blog.csdn.net/Eunice_fan1207/article/details/99674021



### epoll_wait的底层工作原理



### epoll水平触发和边缘触发的区别

水平触发：只要缓冲内容不为空，LT模式返回读就绪。只要缓冲区还不满，LT模式会返回写就绪。

边缘触发：（1）当缓冲区由不可读变为可读的时候，即缓冲区由空变为不空的时候。

（2）当有新数据到达时，即缓冲区中的待读数据变多的时候。

（3）当缓冲区有数据可读，且应用进程对相应的描述符进行`EPOLL_CTL_MOD` 修改`EPOLLIN`事件时。

（1）当缓冲区由不可写变为可写时。

（2）当有旧数据被发送走，即缓冲区中的内容变少的时候。

（3）当缓冲区有空间可写，且应用进程对相应的描述符进行`EPOLL_CTL_MOD` 修改`EPOLLOUT`事件时。



### select, epoll, poll的区别和优缺点





### 一个进程的地址空间分为几段

内核空间和用户空间

用户空间参考C内存模型



  ### 缓存的管理方式（LRU，LFU）

FIFO：First In First Out，先进先出。判断被存储的时间，离目前最远的数据优先被淘汰。
LRU：Least Recently Used，最近最少使用。判断最近被使用的时间，目前最远的数据优先被淘汰。
LFU：Least Frequently Used，最不经常使用。在一段时间内，数据被使用次数最少的，优先被淘汰。



### 锁的种类

1. 互斥锁：只要锁的持有状态没有改变，加锁操作就肯定是失败的。所以，抢锁失败后只要锁的持有状态一直没有改变，那就让出 CPU 给别的线程先执行好了
3. 自旋锁：只要没有锁上，就不断重试。显然，如果别的线程长期持有该锁，那么你这个线程就一直在 while while while 地检查是否能够加锁，浪费 CPU 做无用功
3. 条件变量
4. 读写锁

https://blog.csdn.net/bian_qing_quan11/article/details/73734157

 有哪几种锁，每种锁的使用场景，你用过哪几种锁，用过信号量吗*

### 死锁

指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。



### 死锁的必要条件

（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3）不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

 我们在用多线程的时候，一般会用到自旋锁和互斥锁，简单介绍一下这两个锁。 

 怎样实现互斥锁？具体代码思想 ？ --我答了一个，然后面试官说这个其实是自旋锁。。。 

 接着上面说的你实现互斥锁的方法，你觉得这样实现能够保证线程安全吗？

怎么加锁比较安全



 将一个文件从内存中写入磁盘，设计一种数据结构来加速这个过程（应该是LSM树） 

磁盘管理是否了解？（提示多了解一下底层原理）











### 什么是系统中断

当CPU收到中断或者异常的信号时，它会暂停执行当前的程序或任务，通过一定的机制跳转到负责处理这个信号的相关处理程序中，在完成对这个信号的处理后再跳回到刚才被打断的程序或任务中。

CPU检查是否有中断/异常信号

根据中断向量到IDT表中取得处理这个向量的中断程序的段选择符

根据取得的段选择符到GDT中找相应的段描述符

CPU根据特权级的判断设定即将运行的中断服务程序要使用的栈的地址

保护当前程序的现场

跳转到中断服务程序的第一条指令开始执行

中断服务程序处理完毕，恢复执行先前中断的程序

https://www.cnblogs.com/aaronLinux/p/10842499.html



### 操作系统的中断号在哪？

系统将所有的中断信号统一进行了编号（一共256个：0～255），这个号称为中断向量，具体哪个中断向量表示哪种中断有的是规定好的，也有的是在给定范围内自行设定的。 中断向量和中断服务程序的对应关系主要是由IDT（中断向量表）负责。操作系统在IDT中设置好各种中断向量对应的中断描述符（一共有三类中断门描述符：任务门、中断门和陷阱门），留待CPU查询使用。而IDT本身的位置是由idtr保存的，当然这个地址也是由OS填充的。



22.liunx下如何shell下查看cpu内存资源使用情况用什么命令

linux里面想杀死一个进程，用什么样的方式？-6/-4 进程里面会收到信号吗?

Linux 查看某个进程内存泄漏的指令

kill一个进程的过程是什么样子的

查看当前网络连接的指令

查看当前内存使用状态的？。。问题记不太清了

 Linux命令 awk，strace，gdb调试相关

Linux常用命令

Linux与Windows最大的区别

平时用linux多吗？二进制的文件的用户和用户组的如何修改？ 

 守护进程了解过吗？作用是什么？ 

如何查看一个进程内存使用的情况？



 CPU流水线 

 缓存一致性协议 

 程序中通过地址读取一个变量的过程（虚拟地址到物理地址，MMU，CR3，转换的细节，这里问了一个我不懂的名词，说是MMU获取页目录地址的过程） 



 高并发下同时操作任务队列

在两个进程中，申请的指针，可能指向同一片内存吗

在同一进程下的两个线程a和b，在线程a中有一个static变量，线程b能访问得到吗，在线程a中，new一个对象，线程b能访问得到吗。

如果（不使用虚拟内存）使用物理内存，可能会出现哪些问题？（回答了一段）（提示）如果同时运行几个程序，有没有可能同时使用到同一段物理内存？（提示）如果直接使用物理内存，在指定内存位置时，是否会出现不存在的情况？（提示）程序在运行时，可能一开始并不知道自己需要开辟多大的内存，如果直接使用物理内存，会造成空间难以分配的的问题